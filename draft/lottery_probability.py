import random
import json
import progress
import itertools

ITERATIONS = 10000


def main():
    # Open the json with the assigned ball combos for the teams. This is generated ahead of time by another script
    with open('combos.json', 'rb') as f:
        teams = json.load(f)

    # Combines all the possible combinations into a pool to be referenced by the random number selection
    combo_pool = []
    for key, combos in teams.items():
        combo_pool.extend(combos)

    # Load the numbers generated by random.org to use as list indexes for drawing combos from the combo_pool. It adds a
    # second layer of randomness beyond just the random module. There are 10000 random numbers between 0 and 104
    with open('random.txt', 'rb') as f:
        random_num_pool = list(f.read().split())

    # Create a dict to store the results of the iterations to be used later for calculating the probability of each
    # owner getting a given draft slot
    results = {x: {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0, 10: 0, 11: 0, 12: 0} for x in teams.keys()}

    # Init the progress bar and start iterating through the number of iterations specified

    bar = progress.Bar(ITERATIONS)
    for x in range(1, ITERATIONS):
        # Start each iteration by resetting the variables used, creating temp versions of the random numbers and teams
        # We shuffle the random number pool and then clone it. The pool is used as the list index to draw from the
        # combo_pool

        teams_still_in_lottery = dict(teams)
        random.shuffle(random_num_pool)
        iterations_random_numbers = list(random_num_pool)
        iterations_combo_pool = list(combo_pool)

        while teams_still_in_lottery:
            # "Draw" a number from the combo pool and if it belongs to a team that hasn't already been picked continue
            # If there is just one team left, don't bother with the checks and move on to the next round
            if len(teams_still_in_lottery) == 1:
                results[teams_still_in_lottery.keys()[0]][12] += 1
                break
            else:
                random.shuffle(iterations_combo_pool)
                draw = random.choice(iterations_combo_pool)
                # draw = combo_pool[int(iterations_random_numbers.pop())]

            for team, team_numbers in teams.items():
                if draw in team_numbers:
                    del teams_still_in_lottery[team]
                    draft_round = 12 - len(teams_still_in_lottery)
                    results[team][draft_round] += 1
                    iterations_combo_pool = [y for y in iterations_combo_pool if y not in team_numbers]
        bar.update(x)

    for team, value in results.items():
        pick_rounds = sorted(value.items(), key=lambda x: x[1])
        adp = pick_rounds[-1][0]
        results[team]['avg'] = adp

    print '\n', json.dumps(results, separators=[',', ':'], indent=2)

    with open('results.json', 'wb') as f:
        f.write(json.dumps(results, separators=[',', ':'], indent=2))


def assign_combos(self):
    tmp_combo_list = []
    for i in itertools.combinations(range(1, 16), 2):
        self.combo_pool.append(i)
        tmp_combo_list.append(i)

    for team, num_of_combos in self.team_odds.items():
        team = team.lower()
        for i in range(num_of_combos):
            if not self.teams_in_lotto.get(team):
                self.teams_in_lotto[team] = []

            combo = random.choice(tmp_combo_list)
            self.teams_in_lotto[team].append(combo)
            tmp_combo_list.remove(combo)
            random.shuffle(tmp_combo_list)

if __name__ == '__main__':
    main()
